<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camille Le Nul - Collection de Mini-Jeux</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap');
        
        :root {
            --primary-color: #ff0000;
            --secondary-color: #ffff00;
            --background-dark: #000000;
            --background-light: #111111;
            --text-color: #ffffff;
            --border-color: #ffffff;
            --highlight-color: #00ffff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: var(--background-dark);
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            user-select: none;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        #game-container {
            width: 800px;
            height: 600px;
            position: relative;
            border: 4px solid var(--border-color);
            overflow: hidden;
            background-color: var(--background-dark);
            margin-left: 150px; /* Espace pour le bouton √† gauche */
        }
        
        /* --- √âCRAN TITRE --- */
        #title-screen {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="50" height="50" fill="%23111"/><rect x="50" y="50" width="50" height="50" fill="%23111"/></svg>');
            background-size: 20px 20px;
            animation: backgroundScroll 10s linear infinite;
        }
        
        @keyframes backgroundScroll {
            0% { background-position: 0 0; }
            100% { background-position: 100px 100px; }
        }
        
        .game-title {
            font-size: 40px;
            margin-bottom: 40px;
            text-shadow: 0 0 10px var(--primary-color), 0 0 20px var(--primary-color);
            animation: textGlow 1.5s ease-in-out infinite alternate;
        }
        
        @keyframes textGlow {
            from { text-shadow: 0 0 5px var(--primary-color), 0 0 10px var(--primary-color); }
            to { text-shadow: 0 0 10px var(--primary-color), 0 0 20px var(--primary-color), 0 0 30px var(--primary-color); }
        }
        
        .title-camille {
            color: var(--secondary-color);
            display: block;
            margin-bottom: 10px;
            font-size: 50px;
            transform: rotate(-5deg);
        }
        
        .menu-container {
            width: 80%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .menu-item {
            background-color: var(--background-light);
            margin: 15px 0;
            padding: 15px;
            border: 3px solid var(--border-color);
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            font-size: 16px;
            width: 100%;
        }
        
        .menu-item:hover {
            transform: scale(1.05);
            border-color: var(--highlight-color);
            box-shadow: 0 0 15px var(--highlight-color);
        }
        
        .menu-item.selected {
            border-color: var(--secondary-color);
            box-shadow: 0 0 15px var(--secondary-color);
        }
        
        .menu-item:before {
            content: "‚òÖ";
            margin-right: 15px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .menu-item:hover:before, .menu-item.selected:before {
            opacity: 1;
        }
        
        .menu-item-icon {
            font-family: 'VT323', monospace;
            font-size: 30px;
            margin-right: 15px;
            min-width: 30px;
            text-align: center;
        }
        
        .start-button {
            position: absolute;
            left: -120px;
            top: 50%;
            transform: translateY(-50%);
            background-color: var(--primary-color);
            color: var(--text-color);
            border: 5px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            width: 100px;
            font-family: 'Press Start 2P', cursive;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
            animation: pulse 1.5s infinite alternate;
            display: block;
            z-index: 100;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.7);
            text-align: center;
            line-height: 1.5;
        }
        
        @keyframes pulse {
            from { transform: scale(1); filter: brightness(1); }
            to { transform: scale(1.1); filter: brightness(1.5); }
        }
        
        .start-button:hover {
            background-color: var(--highlight-color);
            animation: none;
            transform: scale(1.2);
            border-color: var(--secondary-color);
        }
        
        /* --- JEUX COMMUN --- */
        .game-screen {
            width: 100%;
            height: 100%;
            display: none;
            position: relative;
            overflow: hidden;
        }
        
        .back-button {
            position: absolute;
            top: 10px;
            left: 10px;
            background: none;
            border: 2px solid var(--border-color);
            color: var(--text-color);
            padding: 5px 10px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            cursor: pointer;
            z-index: 100;
        }
        
        .back-button:hover {
            background-color: var(--border-color);
            color: var(--background-dark);
        }
        
        /* --- COMBAT UNDERTALE --- */
        #undertale-game {
            background-color: var(--background-dark);
            font-family: 'Press Start 2P', cursive;
        }
        
        #battle-zone {
            width: 400px;
            height: 150px;
            border: 4px solid white;
            position: absolute;
            top: 250px;
            left: 200px;
        }
        
        #player-heart {
            width: 20px;
            height: 20px;
            background-color: var(--primary-color);
            position: absolute;
            transform: translate(-50%, -50%);
            transition: filter 0.1s;
        }
        
        #action-menu {
            position: absolute;
            bottom: 50px;
            left: 50px;
            display: flex;
            gap: 50px;
        }
        
        .action-button {
            font-family: 'Press Start 2P', cursive;
            color: white;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            outline: none;
            position: relative;
        }
        
        .action-button:hover {
            color: var(--secondary-color);
        }
        
        .action-button:hover::before {
            content: '‚òÖ';
            position: absolute;
            left: -25px;
            animation: pulse 1s infinite alternate;
        }
        
        #dialogue-box {
            position: absolute;
            bottom: 150px;
            left: 50px;
            width: 700px;
            height: 80px;
            border: 4px solid white;
            padding: 15px;
            font-size: 18px;
            display: none;
            background-color: rgba(0, 0, 0, 0.8);
        }
        
        #stats {
            position: absolute;
            top: 50px;
            left: 50px;
            font-size: 18px;
        }
        
        #enemy-container {
            position: absolute;
            top: 100px;
            left: 400px;
            transform: translateX(-50%);
            text-align: center;
        }
        
        .enemy-sprite {
            font-size: 100px;
            filter: drop-shadow(0 0 10px var(--highlight-color));
            animation: enemyFloat 3s ease-in-out infinite;
        }
        
        @keyframes enemyFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .attack-bone {
            position: absolute;
            width: 20px;
            height: 80px;
            background: linear-gradient(to bottom, white 75%, rgba(0,0,0,0) 25%);
            background-size: 100% 20px;
            background-repeat: repeat-y;
        }
        
        .attack-bone.top {
            top: 0;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }
        
        .attack-bone.bottom {
            bottom: 0;
            border-top-left-radius: 10px;
            border-top-right-radius: 10px;
        }
        
        #game-over, #victory {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            display: none;
            z-index: 100;
        }
        
        #game-over {
            color: var(--primary-color);
        }
        
        #victory {
            color: var(--secondary-color);
        }
        
        .restart-button {
            margin-top: 30px;
            font-family: 'Press Start 2P', cursive;
            background: none;
            border: 3px solid;
            color: inherit;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        
        /* --- JEU DE PLATEFORME --- */
        #platformer-game {
            background-color: #6495ED; /* Ciel bleu */
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
        }
        
        .ground {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 80px;
            background-color: #8B4513; /* Marron */
            border-top: 5px solid #556B2F; /* Vert fonc√© */
        }
        
        .platform {
            position: absolute;
            height: 30px;
            background-color: #8B4513;
            border-top: 5px solid #556B2F;
        }
        
        #player {
            position: absolute;
            width: 40px;
            height: 60px;
            bottom: 80px;
            left: 100px;
            font-size: 30px;
            text-align: center;
            line-height: 60px;
        }
        
        .enemy-platform {
            position: absolute;
            width: 30px;
            height: 30px;
            font-size: 20px;
            text-align: center;
            line-height: 30px;
            animation: enemyBob 2s infinite alternate ease-in-out;
        }
        
        @keyframes enemyBob {
            from { transform: translateY(0); }
            to { transform: translateY(-10px); }
        }
        
        .coin {
            position: absolute;
            width: 20px;
            height: 20px;
            font-size: 20px;
            text-align: center;
            line-height: 20px;
            color: gold;
            animation: coinSpin 1s infinite alternate;
        }
        
        @keyframes coinSpin {
            from { transform: scale(1); }
            to { transform: scale(1.2); }
        }
        
        #platformer-hud {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 2px solid white;
            font-size: 14px;
        }
        
        /* --- JEU DE RYTHME --- */
        #rhythm-game {
            background-color: #000;
            font-family: 'Press Start 2P', cursive;
            perspective: 1000px;
            overflow: hidden;
        }
        
        .highway {
            position: absolute;
            width: 400px;
            height: 500px;
            top: 50px;
            left: 50%;
            transform: translateX(-50%) rotateX(60deg);
            background: linear-gradient(to bottom, #111 10%, #333 90%);
            border: 5px solid #555;
            display: flex;
            justify-content: space-around;
            perspective: 800px;
        }
        
        .lane {
            width: 60px;
            height: 100%;
            border-right: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }
        
        .lane:last-child {
            border-right: none;
        }
        
        .target-zone {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.3);
        }
        
        .note {
            position: absolute;
            width: 50px;
            height: 20px;
            top: 0;
            left: 5px;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .button-container {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
        }
        
        .rhythm-button {
            width: 60px;
            height: 60px;
            background-color: #333;
            border: 3px solid white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            cursor: pointer;
            transition: all 0.1s;
        }
        
        .rhythm-button:active, .rhythm-button.pressed {
            background-color: var(--highlight-color);
            transform: scale(0.9);
        }
        
        #rhythm-score {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            color: white;
        }
        
        #combo-display {
            position: absolute;
            top: 50px;
            right: 10px;
            font-size: 18px;
            color: var(--secondary-color);
        }
        
        #feedback-display {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 36px;
            color: white;
            opacity: 0;
            transition: opacity 0.2s, transform 0.3s;
        }
        
        /* --- JEU DE QUIZ --- */
        #quiz-game {
            background-color: #330033;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .quiz-container {
            width: 90%;
            max-width: 700px;
        }
        
        .quiz-header {
            font-size: 24px;
            color: var(--secondary-color);
            margin-bottom: 20px;
            text-align: center;
        }
        
        .question-container {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border: 3px solid var(--border-color);
            margin-bottom: 20px;
        }
        
        .question-text {
            font-size: 18px;
            margin-bottom: 20px;
            line-height: 1.4;
        }
        
        .quiz-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .quiz-option {
            background-color: var(--background-light);
            padding: 15px;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        .quiz-option:hover {
            background-color: var(--highlight-color);
            color: var(--background-dark);
        }
        
        #quiz-feedback {
            height: 60px;
            font-size: 20px;
            color: var(--highlight-color);
            margin: 20px 0;
            text-align: center;
        }
        
        #quiz-score {
            font-size: 18px;
            color: var(--secondary-color);
            margin-top: 20px;
            text-align: center;
        }
        
        /* --- JEU DE LABYRINTHE --- */
        #maze-game {
            background-color: #000022;
            font-family: 'Press Start 2P', cursive;
        }
        
        .maze-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: black;
            border: 3px solid var(--border-color);
        }
        
        .maze-row {
            display: flex;
        }
        
        .maze-cell {
            width: 30px;
            height: 30px;
            position: relative;
        }
        
        .maze-wall {
            background-color: #1a237e; /* Bleu fonc√© */
            border: 1px solid #303f9f;
            box-shadow: 0 0 5px #3f51b5;
        }
        
        .maze-player {
            position: absolute;
            width: 100%;
            height: 100%;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--primary-color);
            z-index: 10;
            animation: playerPulse 1s infinite alternate;
        }
        
        @keyframes playerPulse {
            from { transform: scale(0.9); }
            to { transform: scale(1.1); }
        }
        
        .maze-end {
            position: absolute;
            width: 100%;
            height: 100%;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--secondary-color);
            animation: endGlow 1.5s infinite alternate;
        }
        
        @keyframes endGlow {
            from { text-shadow: 0 0 5px var(--secondary-color); }
            to { text-shadow: 0 0 20px var(--secondary-color); }
        }
        
        .maze-status {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 16px;
            color: white;
        }
        
        /* --- EFFETS COMMUNS ET ANIMATIONS --- */
        .pixel-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            z-index: 1000;
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            grid-template-rows: repeat(15, 1fr);
            opacity: 0;
            pointer-events: none;
        }
        
        .pixel {
            background-color: var(--primary-color);
        }
        
        @keyframes pixelFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes pixelFadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        .scanline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: rgba(255, 255, 255, 0.1);
            pointer-events: none;
            z-index: 900;
            animation: scanlineMove 8s linear infinite;
        }
        
        @keyframes scanlineMove {
            from { top: -2px; }
            to { top: 600px; }
        }
        
        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 100px black;
            pointer-events: none;
            z-index: 800;
        }
        
        .crt-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(255, 255, 255, 0.03) 50%, rgba(0, 0, 0, 0.03) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 700;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- √âcran titre -->
        <div id="title-screen">
            <h1 class="game-title">
                <span class="title-camille">CAMILLE LE NUL</span>
                COLLECTION DE MINI-JEUX
            </h1>
            
                        <div class="menu-container">
                <div class="menu-item" data-game="undertale">
                    <span class="menu-item-icon">‚ò†</span>
                    Mode Combat (style Undertale)
                </div>
                <div class="menu-item" data-game="platformer">
                    <span class="menu-item-icon">üèÉ</span>
                    Camille Run (Platformer)
                </div>
                <div class="menu-item" data-game="rhythm">
                    <span class="menu-item-icon">üéµ</span>
                    Camille Beat (Jeu de Rythme)
                </div>
                <div class="menu-item" data-game="maze">
                    <span class="menu-item-icon">üåÄ</span>
                    Labyrinthe Nul
                </div>
                <div class="menu-item" data-game="quiz">
                    <span class="menu-item-icon">‚ùì</span>
                    Quiz Camille
                </div>
            </div>
            
            <button class="start-button">JOUER !</button>
            
            <!-- Notification visible pour le premier lancement -->
            <div id="startup-notification" style="position: absolute; bottom: 20px; left: 0; width: 100%; text-align: center; color: white; font-size: 16px; padding: 10px; background-color: rgba(0,0,0,0.8); z-index: 1000;">
                S√©lectionnez un jeu et cliquez sur JOUER !
            </div>
        </div>
        
        <!-- Jeu de combat Undertale -->
        <div id="undertale-game" class="game-screen">
            <button class="back-button">‚Üê RETOUR</button>
            
            <div id="stats">
                CAMILLE LV 1 HP: <span id="hp">20</span>/20
            </div>
            
            <div id="enemy-container">
                <div class="enemy-sprite">‚ò†</div>
                <div id="enemy-name">CAMILLE LE NUL</div>
            </div>
            
            <div id="battle-zone">
                <div id="player-heart"></div>
            </div>
            
            <div id="dialogue-box"></div>
            
            <div id="action-menu">
                <button class="action-button" id="fight">FIGHT</button>
                <button class="action-button" id="act">ACT</button>
                <button class="action-button" id="item">ITEM</button>
                <button class="action-button" id="mercy">MERCY</button>
            </div>
            
            <div id="game-over">
                GAME OVER
                <button class="restart-button">R√©essayer</button>
            </div>
            
            <div id="victory">
                VICTOIRE !
                <button class="restart-button">Rejouer</button>
            </div>
        </div>
        
        <!-- Jeu de plateforme -->
        <div id="platformer-game" class="game-screen">
            <button class="back-button">‚Üê RETOUR</button>
            
            <div id="platformer-hud">
                PI√àCES: <span id="coin-count">0</span>/10
            </div>
            
            <div class="ground"></div>
            <div id="player">üèÉ</div>
        </div>
        
        <!-- Jeu de rythme -->
        <div id="rhythm-game" class="game-screen">
            <button class="back-button">‚Üê RETOUR</button>
            
            <div id="rhythm-score">SCORE: 0</div>
            <div id="combo-display">COMBO: x1</div>
            
            <div class="highway">
                <div class="lane" id="lane1">
                    <div class="target-zone"></div>
                </div>
                <div class="lane" id="lane2">
                    <div class="target-zone"></div>
                </div>
                <div class="lane" id="lane3">
                    <div class="target-zone"></div>
                </div>
                <div class="lane" id="lane4">
                    <div class="target-zone"></div>
                </div>
            </div>
            
            <div class="button-container">
                <div class="rhythm-button" id="button1">D</div>
                <div class="rhythm-button" id="button2">F</div>
                <div class="rhythm-button" id="button3">J</div>
                <div class="rhythm-button" id="button4">K</div>
            </div>
            
            <div id="feedback-display"></div>
        </div>
        
        <!-- Jeu de Quiz -->
        <div id="quiz-game" class="game-screen">
            <button class="back-button">‚Üê RETOUR</button>
            
            <div class="quiz-container">
                <div class="quiz-header">Quiz Camille Le Nul</div>
                
                <div class="question-container">
                    <div class="question-text" id="question-text">Chargement de la question...</div>
                    
                    <div class="quiz-options">
                        <div class="quiz-option" data-index="0">Option 1</div>
                        <div class="quiz-option" data-index="1">Option 2</div>
                        <div class="quiz-option" data-index="2">Option 3</div>
                        <div class="quiz-option" data-index="3">Option 4</div>
                    </div>
                </div>
                
                <div id="quiz-feedback"></div>
                <div id="quiz-score">Score: 0/0</div>
            </div>
        </div>
        
        <!-- Jeu de labyrinthe -->
        <div id="maze-game" class="game-screen">
            <button class="back-button">‚Üê RETOUR</button>
            
            <div class="maze-container" id="maze-container"></div>
            <div class="maze-status">Utilisez les fl√®ches pour d√©placer Camille √† travers le labyrinthe!</div>
        </div>
        
        <!-- Effets visuels communs -->
        <div class="scanline"></div>
        <div class="vignette"></div>
        <div class="crt-effect"></div>
        <div class="pixel-transition" id="transition"></div>
    </div>
    
    <script>
        // SYST√àME PRINCIPAL DE GESTION DES JEUX
        document.addEventListener('DOMContentLoaded', () => {
            const gameContainer = document.getElementById('game-container');
            const titleScreen = document.getElementById('title-screen');
            const menuItems = document.querySelectorAll('.menu-item');
            const startButton = document.querySelector('.start-button');
            const backButtons = document.querySelectorAll('.back-button');
            const transition = document.getElementById('transition');
            
            // √âtat global
            let currentGame = null;
            let selectedGame = null;
            
            // Remplir la transition avec des pixels
            for (let i = 0; i < 300; i++) {
                const pixel = document.createElement('div');
                pixel.className = 'pixel';
                transition.appendChild(pixel);
            }
            
            // S√©lection de jeu dans le menu
            menuItems.forEach(item => {
                item.addEventListener('click', () => {
                    // D√©s√©lectionner l'ancien item
                    menuItems.forEach(i => i.classList.remove('selected'));
                    // S√©lectionner le nouvel item
                    item.classList.add('selected');
                    selectedGame = item.getAttribute('data-game');
                    
                    // Jouer un son de s√©lection
                    playSound('select');
                });
            });
            
            // Bouton de d√©marrage
            startButton.addEventListener('click', () => {
                if (!selectedGame) {
                    // Aucun jeu s√©lectionn√©, s√©lectionner le premier par d√©faut
                    selectedGame = menuItems[0].getAttribute('data-game');
                    menuItems[0].classList.add('selected');
                }
                
                playSound('start');
                startGame(selectedGame);
            });
            
            // Boutons de retour
            backButtons.forEach(button => {
                button.addEventListener('click', () => {
                    playSound('back');
                    returnToTitle();
                });
            });
            
            // Fonction pour d√©marrer un jeu
            function startGame(game) {
                currentGame = game;
                transitionToScreen(() => {
                    titleScreen.style.display = 'none';
                    document.getElementById(`${game}-game`).style.display = 'block';
                    
                    // Initialiser le jeu sp√©cifique
                    switch (game) {
                        case 'undertale':
                            initUndertaleGame();
                            break;
                        case 'platformer':
                            initPlatformerGame();
                            break;
                        case 'rhythm':
                            initRhythmGame();
                            break;
                        case 'quiz':
                            initQuizGame();
                            break;
                        case 'maze':
                            initMazeGame();
                            break;
                    }
                });
            }
            
            // Fonction pour retourner √† l'√©cran titre
            function returnToTitle() {
                transitionToScreen(() => {
                    // Cacher tous les √©crans de jeu
                    document.querySelectorAll('.game-screen').forEach(screen => {
                        screen.style.display = 'none';
                    });
                    
                    // Arr√™ter le jeu actuel
                    switch (currentGame) {
                        case 'undertale':
                            stopUndertaleGame();
                            break;
                        case 'platformer':
                            stopPlatformerGame();
                            break;
                        case 'rhythm':
                            stopRhythmGame();
                            break;
                        case 'quiz':
                            // Le quiz n'a pas besoin d'√™tre arr√™t√©
                            break;
                        case 'maze':
                            // Le labyrinthe n'a pas besoin d'√™tre arr√™t√©
                            break;
                    }
                    
                    // Afficher l'√©cran titre
                    titleScreen.style.display = 'flex';
                    currentGame = null;
                });
            }
            
            // Animation de transition entre les √©crans
            function transitionToScreen(callback) {
                const pixels = transition.querySelectorAll('.pixel');
                
                // Faire appara√Ætre les pixels dans un ordre al√©atoire
                const pixelArray = Array.from(pixels);
                pixelArray.sort(() => Math.random() - 0.5);
                
                // Animation de fondu
                transition.style.opacity = '1';
                pixelArray.forEach((pixel, index) => {
                    setTimeout(() => {
                        pixel.style.backgroundColor = getRandomColor();
                    }, index * 5);
                });
                
                // Ex√©cuter le callback au milieu de la transition
                setTimeout(() => {
                    callback();
                    
                    // Animation de disparition
                    setTimeout(() => {
                        pixelArray.forEach((pixel, index) => {
                            setTimeout(() => {
                                pixel.style.backgroundColor = 'transparent';
                            }, index * 5);
                        });
                        
                        setTimeout(() => {
                            transition.style.opacity = '0';
                        }, pixels.length * 5 + 100);
                    }, 500);
                }, pixels.length * 5 + 300);
            }
            
            // Fonction pour obtenir une couleur al√©atoire
            function getRandomColor() {
                const colors = ['#ff0000', '#ffff00', '#00ffff', '#ff00ff', '#00ff00', '#0000ff'];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            // Syst√®me de son simple
            function playSound(type) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                switch (type) {
                    case 'select':
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(880, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                    case 'start':
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(660, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(880, audioContext.currentTime + 0.1);
                        oscillator.frequency.setValueAtTime(1320, audioContext.currentTime + 0.2);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime + 0.2);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    case 'back':
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(440, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                    case 'hit':
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(110, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.1);
                        break;
                    case 'perfect':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(1320, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                    case 'miss':
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(110, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                    case 'coin':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(1320, audioContext.currentTime + 0.05);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.1);
                        break;
                    case 'victory':
                        const o1 = audioContext.createOscillator();
                        const o2 = audioContext.createOscillator();
                        const g1 = audioContext.createGain();
                        const g2 = audioContext.createGain();
                        
                        o1.connect(g1);
                        o2.connect(g2);
                        g1.connect(audioContext.destination);
                        g2.connect(audioContext.destination);
                        
                        o1.type = 'square';
                        o2.type = 'triangle';
                        
                        o1.frequency.setValueAtTime(440, audioContext.currentTime);
                        o1.frequency.setValueAtTime(554, audioContext.currentTime + 0.2);
                        o1.frequency.setValueAtTime(659, audioContext.currentTime + 0.4);
                        
                        o2.frequency.setValueAtTime(880, audioContext.currentTime);
                        o2.frequency.setValueAtTime(1108, audioContext.currentTime + 0.2);
                        o2.frequency.setValueAtTime(1318, audioContext.currentTime + 0.4);
                        
                        g1.gain.setValueAtTime(0.1, audioContext.currentTime);
                        g2.gain.setValueAtTime(0.05, audioContext.currentTime);
                        
                        g1.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);
                        g2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);
                        
                        o1.start();
                        o2.start();
                        o1.stop(audioContext.currentTime + 0.6);
                        o2.stop(audioContext.currentTime + 0.6);
                        break;
                }
            }
            
            //===================================
            // JEU DE COMBAT STYLE UNDERTALE
            //===================================
            const battleZone = document.getElementById('battle-zone');
            const playerHeart = document.getElementById('player-heart');
            const dialogueBox = document.getElementById('dialogue-box');
            const hpDisplay = document.getElementById('hp');
            const gameOver = document.getElementById('game-over');
            const victory = document.getElementById('victory');
            
            // Boutons d'action
            const fightButton = document.getElementById('fight');
            const actButton = document.getElementById('act');
            const itemButton = document.getElementById('item');
            const mercyButton = document.getElementById('mercy');
            
            // √âtat du jeu Undertale
            let undertaleState = {
                hp: 20,
                playerX: 0,
                playerY: 0,
                playerSpeed: 4,
                keysPressed: {},
                isPlayerTurn: true,
                isFightMode: false,
                isDialogueOpen: false,
                enemyHP: 100,
                mercyPoints: 0,
                attackBones: [],
                attackPattern: 0,
                dialogueIndex: 0,
                enemyName: "CAMILLE LE NUL",
                gameLoopId: null,
                invincible: false
            };
            
            // Dialogues
            const dialogues = [
                "Bonjour humain... Je suis CAMILLE LE NUL, le squelette.",
                "Tu as l'air perdu... NYEH HEH HEH!",
                "Je ne peux pas te laisser passer!",
                "Je dois te capturer pour devenir GRAND!",
                "PREPARE-TOI AU COMBAT!",
                "* CAMILLE LE NUL bloque le chemin!"
            ];
            
            const actDialogues = [
                "* Tu complimentes CAMILLE LE NUL sur son style.",
                "* CAMILLE LE NUL est flatt√©!",
                "* Tu dis √† CAMILLE LE NUL que tu aimes les puzzles.",
                "* CAMILLE LE NUL est impressionn√© par ton go√ªt!",
                "* Tu dis √† CAMILLE LE NUL que tu veux √™tre son ami.",
                "* CAMILLE LE NUL semble confus... mais heureux!"
            ];
            
            const itemDialogues = [
                "* Tu manges des spaghettis!",
                "* C'est... indescriptible.",
                "* Tu as r√©cup√©r√© 5 HP!",
                "* Tu montres des spaghettis √† CAMILLE LE NUL.",
                "* CAMILLE LE NUL est impressionn√© par ta cuisine!",
                "* Tu n'as aucun objet..."
            ];
            
            const mercyDialogues = [
                "* Tu essaies d'√©pargner CAMILLE LE NUL.",
                "* CAMILLE LE NUL n'est pas pr√™t √† t'√©pargner... pour l'instant.",
                "* Tu continues d'√©pargner CAMILLE LE NUL.",
                "* CAMILLE LE NUL h√©site...",
                "* Tu √©pargnes CAMILLE LE NUL de tout ton c≈ìur!",
                "* CAMILLE LE NUL accepte ta merci!"
            ];
            
            function initUndertaleGame() {
                // R√©initialiser l'√©tat du jeu
                undertaleState = {
                    hp: 20,
                    playerX: battleZone.offsetWidth / 2,
                    playerY: battleZone.offsetHeight / 2,
                    playerSpeed: 4,
                    keysPressed: {},
                    isPlayerTurn: true,
                    isFightMode: false,
                    isDialogueOpen: false,
                    enemyHP: 100,
                    mercyPoints: 0,
                    attackBones: [],
                    attackPattern: 0,
                    dialogueIndex: 0,
                    enemyName: "CAMILLE LE NUL",
                    gameLoopId: null,
                    invincible: false
                };
                
                // Positionner le c≈ìur au centre de la zone de combat
                updateHeartPosition();
                
                // Afficher les HP
                hpDisplay.textContent = undertaleState.hp;
                
                // Cacher les √©crans de fin
                gameOver.style.display = 'none';
                victory.style.display = 'none';
                
                // D√©marrer la s√©quence d'introduction
                startIntroDialogue();
                
                // Mettre en place les √©v√©nements
                setupUndertaleEvents();
                
                // D√©marrer la boucle de jeu
                undertaleState.gameLoopId = requestAnimationFrame(undertaleGameLoop);
            }
            
            function stopUndertaleGame() {
                if (undertaleState.gameLoopId) {
                    cancelAnimationFrame(undertaleState.gameLoopId);
                    undertaleState.gameLoopId = null;
                }
                
                // Nettoyer les os d'attaque
                undertaleState.attackBones.forEach(bone => {
                    if (bone.element && bone.element.parentNode) {
                        bone.element.remove();
                    }
                });
                undertaleState.attackBones = [];
                
                // R√©initialiser la position du c≈ìur
                playerHeart.style.left = "50%";
                playerHeart.style.top = "50%";
                
                // Fermer la bo√Æte de dialogue
                dialogueBox.style.display = 'none';
            }
            
            function setupUndertaleEvents() {
                // √âcouteurs pour les touches du clavier
                window.addEventListener('keydown', handleUndertaleKeyDown);
                window.addEventListener('keyup', handleUndertaleKeyUp);
                
                // √âcouteurs pour les boutons d'action
                fightButton.addEventListener('click', handleFight);
                actButton.addEventListener('click', handleAct);
                itemButton.addEventListener('click', handleItem);
                mercyButton.addEventListener('click', handleMercy);
                
                // Boutons de red√©marrage
                document.querySelectorAll('#undertale-game .restart-button').forEach(button => {
                    button.addEventListener('click', initUndertaleGame);
                });
            }
            
            function handleUndertaleKeyDown(e) {
                undertaleState.keysPressed[e.key] = true;
                
                if (e.key === 'Enter' || e.key === ' ') {
                    advanceDialogue();
                }
                
                // √âviter le d√©filement de la page avec les fl√®ches
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                    e.preventDefault();
                }
            }
            
            function handleUndertaleKeyUp(e) {
                undertaleState.keysPressed[e.key] = false;
            }
            
            function undertaleGameLoop() {
                if (!undertaleState.isDialogueOpen && !undertaleState.isFightMode) {
                    updatePlayerMovement();
                }
                
                if (undertaleState.isFightMode) {
                    updateAttacks();
                }
                
                undertaleState.gameLoopId = requestAnimationFrame(undertaleGameLoop);
            }
            
            function updatePlayerMovement() {
                let dx = 0;
                let dy = 0;
                
                if (undertaleState.keysPressed['ArrowUp'] || undertaleState.keysPressed['z'] || undertaleState.keysPressed['w']) {
                    dy -= undertaleState.playerSpeed;
                }
                if (undertaleState.keysPressed['ArrowDown'] || undertaleState.keysPressed['s']) {
                    dy += undertaleState.playerSpeed;
                }
                if (undertaleState.keysPressed['ArrowLeft'] || undertaleState.keysPressed['q'] || undertaleState.keysPressed['a']) {
                    dx -= undertaleState.playerSpeed;
                }
                if (undertaleState.keysPressed['ArrowRight'] || undertaleState.keysPressed['d']) {
                    dx += undertaleState.playerSpeed;
                }
                
                // Mise √† jour de la position avec collision aux bords
                const bounds = battleZone.getBoundingClientRect();
                const heartRect = playerHeart.getBoundingClientRect();
                
                const minX = bounds.left + 10;
                const maxX = bounds.right - 10;
                const minY = bounds.top + 10;
                const maxY = bounds.bottom - 10;
                
                const newX = Math.max(minX, Math.min(maxX, heartRect.left + dx));
                const newY = Math.max(minY, Math.min(maxY, heartRect.top + dy));
                
                undertaleState.playerX = newX - bounds.left;
                undertaleState.playerY = newY - bounds.top;
                
                updateHeartPosition();
                checkCollisions();
            }
            
            function updateHeartPosition() {
                playerHeart.style.left = `${undertaleState.playerX}px`;
                playerHeart.style.top = `${undertaleState.playerY}px`;
            }
            
            function startIntroDialogue() {
                undertaleState.isDialogueOpen = true;
                dialogueBox.style.display = 'block';
                showDialogue(dialogues[0]);
                undertaleState.dialogueIndex = 1;
            }
            
            function advanceDialogue() {
                if (!undertaleState.isDialogueOpen) return;
                
                if (undertaleState.dialogueIndex < dialogues.length) {
                    showDialogue(dialogues[undertaleState.dialogueIndex]);
                    undertaleState.dialogueIndex++;
                } else {
                    undertaleState.isDialogueOpen = false;
                    dialogueBox.style.display = 'none';
                }
            }
            
            function showDialogue(text) {
                dialogueBox.textContent = '';
                let i = 0;
                const interval = setInterval(() => {
                    dialogueBox.textContent += text[i];
                    i++;
                    if (i >= text.length) {
                        clearInterval(interval);
                    }
                }, 30);
            }
            
            function updateAttacks() {
                const bounds = battleZone.getBoundingClientRect();
                
                // Mettre √† jour les os d'attaque
                undertaleState.attackBones.forEach(bone => {
                    const boneElement = bone.element;
                    bone.x += bone.speed;
                    boneElement.style.left = bone.x + 'px';
                    
                    // Supprimer les os sortis de l'√©cran
                    if (bone.x < -50 || bone.x > bounds.width + 50) {
                        boneElement.remove();
                        undertaleState.attackBones = undertaleState.attackBones.filter(b => b !== bone);
                    }
                });
                
                // Cr√©er de nouveaux os si n√©cessaire
                if (undertaleState.attackBones.length < 5 && Math.random() < 0.02) {
                    createBone();
                }
                
                checkCollisions();
            }
            
            function createBone() {
                const bone = document.createElement('div');
                bone.className = 'attack-bone';
                
                const isTop = Math.random() > 0.5;
                bone.classList.add(isTop ? 'top' : 'bottom');
                
                const height = 20 + Math.floor(Math.random() * 60);
                bone.style.height = height + 'px';
                
                let x, speed;
                
                // Selon le pattern d'attaque
                switch(undertaleState.attackPattern) {
                    case 0: // Attaque de gauche √† droite
                        x = -40;
                        speed = 2 + Math.random() * 3;
                        break;
                    case 1: // Attaque de droite √† gauche
                        x = battleZone.offsetWidth + 40;
                        speed = -(2 + Math.random() * 3);
                        break;
                    case 2: // Attaque mixte
                        if (Math.random() > 0.5) {
                            x = -40;
                            speed = 2 + Math.random() * 4;
                        } else {
                            x = battleZone.offsetWidth + 40;
                            speed = -(2 + Math.random() * 4);
                        }
                        break;
                }
                
                bone.style.left = x + 'px';
                
                if (isTop) {
                    bone.style.top = '0';
                } else {
                    bone.style.bottom = '0';
                }
                
                battleZone.appendChild(bone);
                
                undertaleState.attackBones.push({
                    element: bone,
                    x: x,
                    y: isTop ? 0 : battleZone.offsetHeight - height,
                    width: 20,
                    height: height,
                    speed: speed,
                    isTop: isTop
                });
            }
            
            function checkCollisions() {
                if (!undertaleState.isFightMode) return;
                
                const heartRect = playerHeart.getBoundingClientRect();
                
                // V√©rifier les collisions avec les os
                for (let i = 0; i < undertaleState.attackBones.length; i++) {
                    const bone = undertaleState.attackBones[i];
                    const boneRect = bone.element.getBoundingClientRect();
                    
                    // D√©tection de collision pr√©cise
                    if (
                        heartRect.left < boneRect.right - 5 &&
                        heartRect.right > boneRect.left + 5 &&
                        heartRect.top < boneRect.bottom - 5 &&
                        heartRect.bottom > boneRect.top + 5
                    ) {
                        takeDamage(1);
                        break; // √âviter les collisions multiples en un seul frame
                    }
                }
            }
            
            function takeDamage(amount) {
                // √âviter les d√©g√¢ts multiples en peu de temps
                if (undertaleState.invincible) return;
                
                undertaleState.hp -= amount;
                hpDisplay.textContent = undertaleState.hp;
                playSound('hit');
                
                // Flash du c≈ìur
                playerHeart.style.filter = "brightness(5)";
                setTimeout(() => {
                    playerHeart.style.filter = "none";
                }, 100);
                
                // Courte p√©riode d'invincibilit√©
                undertaleState.invincible = true;
                setTimeout(() => {
                    undertaleState.invincible = false;
                }, 1000);
                
                // V√©rifier game over
                if (undertaleState.hp <= 0) {
                    endUndertaleGame(false);
                }
            }
            
            function handleFight() {
                if (!undertaleState.isPlayerTurn || undertaleState.isDialogueOpen) return;
                
                playSound('select');
                undertaleState.isDialogueOpen = true;
                dialogueBox.style.display = 'block';
                
                showDialogue("* Tu attaques CAMILLE LE NUL!");
                
                setTimeout(() => {
                    // Attaque
                    const damage = 10 + Math.floor(Math.random() * 5);
                    undertaleState.enemyHP -= damage;
                    showDialogue(`* Tu infliges ${damage} points de d√©g√¢ts!`);
                    
                    // V√©rifier victoire
                    if (undertaleState.enemyHP <= 0) {
                        setTimeout(() => {
                            showDialogue("* CAMILLE LE NUL a √©t√© vaincu!");
                            setTimeout(() => {
                                endUndertaleGame(true);
                            }, 2000);
                        }, 1500);
                    } else {
                        // Tour de l'ennemi
                        setTimeout(() => {
                            startEnemyTurn();
                        }, 1500);
                    }
                }, 1500);
            }
            
            function handleAct() {
                if (!undertaleState.isPlayerTurn || undertaleState.isDialogueOpen) return;
                
                playSound('select');
                undertaleState.isDialogueOpen = true;
                dialogueBox.style.display = 'block';
                
                const dialogueIndex = Math.min(4, Math.floor(undertaleState.mercyPoints / 2) * 2);
                showDialogue(actDialogues[dialogueIndex]);
                
                setTimeout(() => {
                    showDialogue(actDialogues[dialogueIndex + 1]);
                    undertaleState.mercyPoints++;
                    
                    // Tour de l'ennemi
                    setTimeout(() => {
                        startEnemyTurn();
                    }, 1500);
                }, 1500);
            }
            
            function handleItem() {
                if (!undertaleState.isPlayerTurn || undertaleState.isDialogueOpen) return;
                
                playSound('select');
                undertaleState.isDialogueOpen = true;
                dialogueBox.style.display = 'block';
                
                if (Math.random() < 0.5) {
                    showDialogue(itemDialogues[0]);
                    
                    setTimeout(() => {
                        showDialogue(itemDialogues[1]);
                        
                        setTimeout(() => {
                            showDialogue(itemDialogues[2]);
                            undertaleState.hp = Math.min(20, undertaleState.hp + 5);
                            hpDisplay.textContent = undertaleState.hp;
                            
                            // Tour de l'ennemi
                            setTimeout(() => {
                                startEnemyTurn();
                            }, 1500);
                        }, 1500);
                    }, 1500);
                } else if (Math.random() < 0.5) {
                    showDialogue(itemDialogues[3]);
                    
                    setTimeout(() => {
                        showDialogue(itemDialogues[4]);
                        undertaleState.mercyPoints++;
                        
                        // Tour de l'ennemi
                        setTimeout(() => {
                            startEnemyTurn();
                        }, 1500);
                    }, 1500);
                } else {
                    showDialogue(itemDialogues[5]);
                    
                    // Tour de l'ennemi
                    setTimeout(() => {
                        startEnemyTurn();
                    }, 1500);
                }
            }
            
            function handleMercy() {
                if (!undertaleState.isPlayerTurn || undertaleState.isDialogueOpen) return;
                
                playSound('select');
                undertaleState.isDialogueOpen = true;
                dialogueBox.style.display = 'block';
                
                if (undertaleState.mercyPoints >= 5) {
                    showDialogue(mercyDialogues[4]);
                    
                    setTimeout(() => {
                        showDialogue(mercyDialogues[5]);
                        
                        setTimeout(() => {
                            showDialogue("* CAMILLE LE NUL t'√©pargne!");
                            
                            setTimeout(() => {
                                endUndertaleGame(true, true);
                            }, 1500);
                        }, 1500);
                    }, 1500);
                } else {
                    const dialogueIndex = Math.min(3, undertaleState.mercyPoints);
                    showDialogue(mercyDialogues[dialogueIndex]);
                    undertaleState.mercyPoints++;
                    
                    // Tour de l'ennemi
                    setTimeout(() => {
                        startEnemyTurn();
                    }, 1500);
                }
            }
            
            function startEnemyTurn() {
                undertaleState.isPlayerTurn = false;
                undertaleState.isDialogueOpen = false;
                undertaleState.isFightMode = true;
                dialogueBox.style.display = 'none';
                
                // Choisir un pattern d'attaque
                undertaleState.attackPattern = Math.floor(Math.random() * 3);
                
                // Dur√©e du tour de l'ennemi
                setTimeout(() => {
                    endEnemyTurn();
                }, 5000 + Math.random() * 3000);
            }
            
            function endEnemyTurn() {
                undertaleState.isPlayerTurn = true;
                undertaleState.isFightMode = false;
                
                // Supprimer tous les os
                undertaleState.attackBones.forEach(bone => {
                    bone.element.remove();
                });
                undertaleState.attackBones = [];
                
                // Message de fin de tour
                undertaleState.isDialogueOpen = true;
                dialogueBox.style.display = 'block';
                showDialogue(`* ${undertaleState.enemyName} attend ta prochaine action.`);
                
                setTimeout(() => {
                    undertaleState.isDialogueOpen = false;
                    dialogueBox.style.display = 'none';
                }, 1500);
            }
            
            function endUndertaleGame(isVictory, isMercy = false) {
                undertaleState.isFightMode = false;
                undertaleState.isDialogueOpen = false;
                dialogueBox.style.display = 'none';
                
                if (isVictory) {
                    playSound('victory');
                    victory.style.display = 'flex';
                    if (isMercy) {
                        victory.querySelector('.restart-button').textContent = "Continuer en ami";
                    } else {
                        victory.querySelector('.restart-button').textContent = "Rejouer";
                    }
                } else {
                    gameOver.style.display = 'flex';
                }
                
                // Supprimer tous les os
                undertaleState.attackBones.forEach(bone => {
                    bone.element.remove();
                });
            }
            
            //===================================
            // JEU DE PLATEFORME
            //===================================
            const platformerGame = document.getElementById('platformer-game');
            const player = document.getElementById('player');
            const coinCountDisplay = document.getElementById('coin-count');
            
            // √âtat du jeu de plateforme
            let platformerState = {
                player: {
                    x: 100,
                    y: 0,
                    width: 40,
                    height: 60,
                    velocityX: 0,
                    velocityY: 0,
                    isJumping: false,
                    speed: 5,
                    jumpPower: 15,
                    gravity: 0.5
                },
                platforms: [],
                coins: [],
                enemies: [],
                coinCount: 0,
                totalCoins: 10,
                gameLoopId: null,
                keysPressed: {}
            };
            
            function initPlatformerGame() {
                // Nettoyer les √©l√©ments existants
                platformerGame.querySelectorAll('.platform, .coin, .enemy-platform').forEach(el => el.remove());
                
                // R√©initialiser l'√©tat du jeu
                platformerState = {
                    player: {
                        x: 100,
                        y: 300, // Commencer plus haut pour √©viter de tomber dans le vide
                        width: 40,
                        height: 60,
                        velocityX: 0,
                        velocityY: 0,
                        isJumping: false,
                        speed: 5,
                        jumpPower: 15,
                        gravity: 0.5
                    },
                    platforms: [],
                    coins: [],
                    enemies: [],
                    coinCount: 0,
                    totalCoins: 10,
                    gameLoopId: null,
                    keysPressed: {}
                };
                
                // Cr√©er les plateformes
                createPlatforms();
                
                // Cr√©er les pi√®ces
                createCoins();
                
                // Cr√©er les ennemis
                createEnemies();
                
                // Mettre √† jour l'affichage du compteur de pi√®ces
                coinCountDisplay.textContent = `${platformerState.coinCount}/${platformerState.totalCoins}`;
                
                // √âv√©nements clavier
                window.removeEventListener('keydown', handlePlatformerKeyDown);
                window.removeEventListener('keyup', handlePlatformerKeyUp);
                window.addEventListener('keydown', handlePlatformerKeyDown);
                window.addEventListener('keyup', handlePlatformerKeyUp);
                
                // D√©marrer la boucle de jeu
                if (platformerState.gameLoopId) {
                    cancelAnimationFrame(platformerState.gameLoopId);
                }
                platformerState.gameLoopId = requestAnimationFrame(platformerGameLoop);
            }
            
            function stopPlatformerGame() {
                if (platformerState.gameLoopId) {
                    cancelAnimationFrame(platformerState.gameLoopId);
                    platformerState.gameLoopId = null;
                }
                
                // Nettoyer les plateformes, pi√®ces et ennemis
                platformerState.platforms.forEach(platform => {
                    platform.element.remove();
                });
                platformerState.coins.forEach(coin => {
                    coin.element.remove();
                });
                platformerState.enemies.forEach(enemy => {
                    enemy.element.remove();
                });
                
                platformerState.platforms = [];
                platformerState.coins = [];
                platformerState.enemies = [];
                
                // Supprimer les √©v√©nements clavier
                window.removeEventListener('keydown', handlePlatformerKeyDown);
                window.removeEventListener('keyup', handlePlatformerKeyUp);
            }
            
            function createPlatforms() {
                // Plateformes statiques
                const platformsData = [
                    { x: 200, y: 400, width: 150 },
                    { x: 400, y: 350, width: 100 },
                    { x: 550, y: 300, width: 120 },
                    { x: 300, y: 250, width: 100 },
                    { x: 150, y: 200, width: 100 },
                    { x: 350, y: 150, width: 150 },
                    { x: 600, y: 200, width: 100 }
                ];
                
                platformsData.forEach(data => {
                    const platformElement = document.createElement('div');
                    platformElement.className = 'platform';
                    platformElement.style.left = `${data.x}px`;
                    platformElement.style.bottom = `${data.y}px`;
                    platformElement.style.width = `${data.width}px`;
                    platformerGame.appendChild(platformElement);
                    
                    platformerState.platforms.push({
                        x: data.x,
                        y: data.y,
                        width: data.width,
                        height: 30,
                        element: platformElement
                    });
                });
            }
            
            function createCoins() {
                // Positions des pi√®ces
                const coinPositions = [
                    { x: 250, y: 450 },
                    { x: 420, y: 400 },
                    { x: 600, y: 350 },
                    { x: 330, y: 300 },
                    { x: 180, y: 250 },
                    { x: 400, y: 200 },
                    { x: 650, y: 250 },
                    { x: 300, y: 500 },
                    { x: 500, y: 450 },
                    { x: 150, y: 400 }
                ];
                
                coinPositions.forEach(pos => {
                    const coinElement = document.createElement('div');
                    coinElement.className = 'coin';
                    coinElement.textContent = 'üí∞';
                    coinElement.style.left = `${pos.x}px`;
                    coinElement.style.bottom = `${pos.y}px`;
                    platformerGame.appendChild(coinElement);
                    
                    platformerState.coins.push({
                        x: pos.x,
                        y: pos.y,
                        width: 20,
                        height: 20,
                        collected: false,
                        element: coinElement
                    });
                });
            }
            
            function createEnemies() {
                // Positions des ennemis
                const enemyPositions = [
                    { x: 300, y: 430, platformIndex: 0 },
                    { x: 450, y: 380, platformIndex: 1 },
                    { x: 600, y: 330, platformIndex: 2 },
                    { x: 350, y: 180, platformIndex: 5 }
                ];
                
                enemyPositions.forEach((pos, index) => {
                    const enemyElement = document.createElement('div');
                    enemyElement.className = 'enemy-platform';
                    enemyElement.textContent = 'üëæ';
                    enemyElement.style.left = `${pos.x}px`;
                    enemyElement.style.bottom = `${pos.y}px`;
                    platformerGame.appendChild(enemyElement);
                    
                    platformerState.enemies.push({
                        x: pos.x,
                        y: pos.y,
                        width: 30,
                        height: 30,
                        direction: 1,
                        speed: 1 + Math.random(),
                        platformIndex: pos.platformIndex,
                        element: enemyElement
                    });
                });
            }
            
            function handlePlatformerKeyDown(e) {
                platformerState.keysPressed[e.key] = true;
                
                // Sauter si sur le sol ou une plateforme
                if ((e.key === 'ArrowUp' || e.key === ' ' || e.key === 'w' || e.key === 'z') && !platformerState.player.isJumping) {
                    platformerState.player.velocityY = platformerState.player.jumpPower;
                    platformerState.player.isJumping = true;
                }
            }
            
            function handlePlatformerKeyUp(e) {
                platformerState.keysPressed[e.key] = false;
            }
            
            function platformerGameLoop() {
                updatePlayer();
                updateEnemies();
                checkCollisions();
                updatePlatformerRender();
                
                platformerState.gameLoopId = requestAnimationFrame(platformerGameLoop);
            }
            
            function updatePlayer() {
                const player = platformerState.player;
                
                // Mouvement horizontal
                player.velocityX = 0;
                if (platformerState.keysPressed['ArrowLeft'] || platformerState.keysPressed['a'] || platformerState.keysPressed['q']) {
                    player.velocityX = -player.speed;
                    document.getElementById('player').innerHTML = "üèÉ";
                    document.getElementById('player').style.transform = "scaleX(-1)";
                }
                if (platformerState.keysPressed['ArrowRight'] || platformerState.keysPressed['d']) {
                    player.velocityX = player.speed;
                    document.getElementById('player').innerHTML = "üèÉ";
                    document.getElementById('player').style.transform = "scaleX(1)";
                }
                
                // Appliquer la gravit√©
                player.velocityY -= player.gravity;
                
                // Tester les collisions horizontales avant de d√©placer
                const newX = player.x + player.velocityX;
                let canMoveX = true;
                
                platformerState.platforms.forEach(platform => {
                    if (
                        player.y + player.height > platform.y &&
                        player.y < platform.y + platform.height &&
                        newX + player.width > platform.x &&
                        newX < platform.x + platform.width
                    ) {
                        canMoveX = false;
                    }
                });
                
                // Appliquer le mouvement horizontal seulement si c'est possible
                if (canMoveX) {
                    player.x = newX;
                }
                
                // Tester les collisions verticales avant de d√©placer
                const newY = player.y + player.velocityY;
                let canMoveY = true;
                let onPlatform = false;
                
                platformerState.platforms.forEach(platform => {
                    // Collision avec une plateforme
                    if (
                        newY < platform.y + platform.height &&
                        newY + player.height > platform.y &&
                        player.x + player.width > platform.x &&
                        player.x < platform.x + platform.width
                    ) {
                        // Si on tombe sur la plateforme (collision par le bas)
                        if (player.velocityY <= 0 && player.y >= platform.y) {
                            player.y = platform.y;
                            player.velocityY = 0;
                            player.isJumping = false;
                            onPlatform = true;
                        } 
                        // Si on saute contre la plateforme (collision par le haut)
                        else if (player.velocityY > 0 && player.y + player.height <= platform.y + platform.height) {
                            player.velocityY = 0;
                        }
                        canMoveY = false;
                    }
                });
                
                // Appliquer le mouvement vertical seulement si c'est possible
                if (canMoveY) {
                    player.y = newY;
                }
                
                // V√©rifier si le joueur est sur le sol
                if (player.y <= 80 && player.velocityY <= 0) {
                    player.y = 80;
                    player.velocityY = 0;
                    player.isJumping = false;
                }
                
                // Si le joueur tombe hors de l'√©cran
                if (player.y < 0) {
                    player.x = 100;
                    player.y = 300;
                    player.velocityY = 0;
                    playSound('hit');
                }
                
                // Emp√™cher de sortir de l'√©cran horizontalement
                const containerWidth = platformerGame.offsetWidth;
                if (player.x < 0) player.x = 0;
                if (player.x + player.width > containerWidth) player.x = containerWidth - player.width;
            }
            
            function updateEnemies() {
                platformerState.enemies.forEach(enemy => {
                    const platform = platformerState.platforms[enemy.platformIndex];
                    
                    // Mouvement sur la plateforme
                    enemy.x += enemy.direction * enemy.speed;
                    
                    // Rebondir aux bords de la plateforme
                    if (enemy.x <= platform.x || enemy.x + enemy.width >= platform.x + platform.width) {
                        enemy.direction *= -1;
                    }
                });
            }
            
            function checkCollisions() {
                const player = platformerState.player;
                
                // V√©rifier les collisions avec les pi√®ces
                platformerState.coins.forEach(coin => {
                    if (!coin.collected &&
                        player.x < coin.x + coin.width &&
                        player.x + player.width > coin.x &&
                        player.y < coin.y + coin.height &&
                        player.y + player.height > coin.y
                    ) {
                        coin.collected = true;
                        coin.element.style.display = 'none';
                        platformerState.coinCount++;
                        coinCountDisplay.textContent = `${platformerState.coinCount}/${platformerState.totalCoins}`;
                        playSound('coin');
                        
                        // Si toutes les pi√®ces sont collect√©es
                        if (platformerState.coinCount >= platformerState.totalCoins) {
                            setTimeout(() => {
                                alert("F√©licitations! Vous avez collect√© toutes les pi√®ces!");
                                returnToTitle();
                            }, 500);
                        }
                    }
                });
                
                // V√©rifier les collisions avec les ennemis
                platformerState.enemies.forEach(enemy => {
                    if (
                        player.x < enemy.x + enemy.width &&
                        player.x + player.width > enemy.x &&
                        player.y < enemy.y + enemy.height &&
                        player.y + player.height > enemy.y
                    ) {
                        // Si le joueur saute sur l'ennemi
                        if (player.velocityY < 0 && player.y > enemy.y + enemy.height / 2) {
                            // Rebondir
                            player.velocityY = player.jumpPower * 0.7;
                            // Repositionner l'ennemi
                            const platform = platformerState.platforms[enemy.platformIndex];
                            enemy.x = platform.x + Math.random() * (platform.width - enemy.width);
                        } else {
                            // Sinon, le joueur est touch√©
                            playSound('hit');
                            player.x = 100;
                            player.y = 300;
                            player.velocityY = 0;
                        }
                    }
                });
            }
            
            function updatePlatformerRender() {
                const player = platformerState.player;
                
                // Mettre √† jour la position du joueur
                document.getElementById('player').style.left = `${player.x}px`;
                document.getElementById('player').style.bottom = `${player.y}px`;
                
                // Mettre √† jour la position des ennemis
                platformerState.enemies.forEach(enemy => {
                    enemy.element.style.left = `${enemy.x}px`;
                    enemy.element.style.bottom = `${enemy.y}px`;
                });
            }
            
            //===================================
            // JEU DE RYTHME
            //===================================
            const rhythmGame = document.getElementById('rhythm-game');
            const scoreDisplay = document.getElementById('rhythm-score');
            const comboDisplay = document.getElementById('combo-display');
            const feedbackDisplay = document.getElementById('feedback-display');
            const lanes = document.querySelectorAll('.lane');
            const buttons = document.querySelectorAll('.rhythm-button');
            
            // √âtat du jeu de rythme
            let rhythmState = {
                score: 0,
                combo: 0,
                notes: [],
                noteSpeed: 3,
                lastNoteTime: 0,
                gameLoopId: null,
                keysPressed: {},
                hitWindow: 100, // ms
                perfectWindow: 50, // ms
                gameStarted: false
            };
            
            function initRhythmGame() {
                // R√©initialiser l'√©tat du jeu
                rhythmState = {
                    score: 0,
                    combo: 0,
                    notes: [],
                    noteSpeed: 3,
                    lastNoteTime: 0,
                    gameLoopId: null,
                    keysPressed: {},
                    hitWindow: 100, // ms
                    perfectWindow: 50, // ms
                    gameStarted: false
                };
                
                // Mettre √† jour l'affichage
                scoreDisplay.textContent = "SCORE: 0";
                comboDisplay.textContent = "COMBO: x1";
                feedbackDisplay.style.opacity = "0";
                
                // Nettoyer les notes existantes
                document.querySelectorAll('.note').forEach(note => note.remove());
                
                // Ajouter les √©v√©nements
                window.addEventListener('keydown', handleRhythmKeyDown);
                window.addEventListener('keyup', handleRhythmKeyUp);
                
                // Assigner les gestionnaires d'√©v√©nements pour chaque bouton
                buttons.forEach((button, index) => {
                    button.removeEventListener('mousedown', buttonEventHandlers[index]);
                    buttonEventHandlers[index] = () => handleRhythmButtonPress(index);
                    button.addEventListener('mousedown', buttonEventHandlers[index]);
                });
                
                // Afficher un message de d√©marrage
                feedbackDisplay.textContent = "PR√äT ?";
                feedbackDisplay.style.opacity = "1";
                feedbackDisplay.style.color = "#00ffff";
                
                setTimeout(() => {
                    feedbackDisplay.textContent = "PARTEZ !";
                    setTimeout(() => {
                        feedbackDisplay.style.opacity = "0";
                        
                        // D√©marrer la boucle de jeu
                        rhythmState.gameStarted = true;
                        rhythmState.lastNoteTime = Date.now();
                        rhythmState.gameLoopId = requestAnimationFrame(rhythmGameLoop);
                    }, 1000);
                }, 1000);
            }
            
            // Stockage pour les gestionnaires d'√©v√©nements des boutons
            const buttonEventHandlers = [null, null, null, null];
            
            function stopRhythmGame() {
                if (rhythmState.gameLoopId) {
                    cancelAnimationFrame(rhythmState.gameLoopId);
                    rhythmState.gameLoopId = null;
                }
                
                // Nettoyer les notes
                document.querySelectorAll('.note').forEach(note => note.remove());
                
                // Enlever les √©v√©nements
                window.removeEventListener('keydown', handleRhythmKeyDown);
                window.removeEventListener('keyup', handleRhythmKeyUp);
                
                buttons.forEach((button, index) => {
                    button.removeEventListener('mousedown', () => handleRhythmButtonPress(index));
                });
                
                rhythmState.gameStarted = false;
            }
            
            function handleRhythmKeyDown(e) {
                // Si la touche √©tait d√©j√† enfonc√©e, ignorer
                if (rhythmState.keysPressed[e.key]) return;
                
                rhythmState.keysPressed[e.key] = true;
                
                // Mapping des touches
                const keyMap = {
                    'd': 0,
                    'f': 1,
                    'j': 2,
                    'k': 3
                };
                
                if (keyMap[e.key] !== undefined) {
                    handleRhythmButtonPress(keyMap[e.key]);
                    buttons[keyMap[e.key]].classList.add('pressed');
                }
            }
            
            function handleRhythmKeyUp(e) {
                rhythmState.keysPressed[e.key] = false;
                
                // Mapping des touches
                const keyMap = {
                    'd': 0,
                    'f': 1,
                    'j': 2,
                    'k': 3
                };
                
                if (keyMap[e.key] !== undefined) {
                    buttons[keyMap[e.key]].classList.remove('pressed');
                }
            }
            
            function handleRhythmButtonPress(laneIndex) {
                const lane = lanes[laneIndex];
                const targetZone = lane.querySelector('.target-zone');
                const targetRect = targetZone.getBoundingClientRect();
                
                // Chercher la note la plus proche dans la zone cible
                let closestNote = null;
                let closestDistance = Infinity;
                
                rhythmState.notes.forEach(note => {
                    if (note.lane === laneIndex && !note.hit) {
                        const noteRect = note.element.getBoundingClientRect();
                        // Distance du centre de la note au centre de la zone cible
                        const noteCenter = noteRect.top + noteRect.height / 2;
                        const targetCenter = targetRect.top + targetRect.height / 2;
                        const distance = Math.abs(noteCenter - targetCenter);
                        
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestNote = note;
                        }
                    }
                });
                
                // Si une note est dans la zone de frappe
                if (closestNote && closestDistance < rhythmState.hitWindow) {
                    closestNote.hit = true;
                    closestNote.element.style.opacity = "0.2";
                    
                    // Augmenter le score et le combo
                    rhythmState.combo++;
                    
                    // D√©terminer la qualit√© de la frappe
                    let points, feedback;
                    if (closestDistance < rhythmState.perfectWindow) {
                        points = 300 * (1 + (rhythmState.combo - 1) * 0.1);
                        feedback = "PERFECT!";
                        playSound('perfect');
                    } else {
                        points = 100 * (1 + (rhythmState.combo - 1) * 0.1);
                        feedback = "GOOD!";
                        playSound('select');
                    }
                    
                    rhythmState.score += Math.floor(points);
                    
                    // Mettre √† jour l'affichage
                    updateRhythmDisplay(feedback);
                } else {
                    // Rat√©
                    rhythmState.combo = 0;
                    updateRhythmDisplay("MISS!");
                    playSound('miss');
                }
            }
            
            function updateRhythmDisplay(feedback) {
                scoreDisplay.textContent = `SCORE: ${rhythmState.score}`;
                comboDisplay.textContent = `COMBO: x${Math.max(1, rhythmState.combo)}`;
                
                // Afficher le feedback
                feedbackDisplay.textContent = feedback;
                feedbackDisplay.style.opacity = "1";
                feedbackDisplay.style.color = feedback === "PERFECT!" ? "#00ff00" : 
                                             feedback === "GOOD!" ? "#ffff00" : "#ff0000";
                
                // Animation de feedback
                feedbackDisplay.style.transform = "translateY(0)";
                setTimeout(() => {
                    feedbackDisplay.style.opacity = "0";
                    feedbackDisplay.style.transform = "translateY(-20px)";
                }, 500);
            }
            
            function rhythmGameLoop() {
                // Cr√©er de nouvelles notes
                if (Date.now() - rhythmState.lastNoteTime > 1000 + Math.random() * 500) {
                    createNote();
                    rhythmState.lastNoteTime = Date.now();
                }
                
                // Mettre √† jour les notes existantes
                updateNotes();
                
                rhythmState.gameLoopId = requestAnimationFrame(rhythmGameLoop);
            }
            
            function createNote() {
                // Choisir une lane al√©atoire
                const laneIndex = Math.floor(Math.random() * 4);
                const lane = lanes[laneIndex];
                
                // Cr√©er l'√©l√©ment de note
                const noteElement = document.createElement('div');
                noteElement.className = 'note';
                noteElement.style.top = "-20px"; // commencer en haut de la lane
                
                lane.appendChild(noteElement);
                
                // Ajouter la note √† l'√©tat du jeu
                rhythmState.notes.push({
                    lane: laneIndex,
                    element: noteElement,
                    position: 0,
                    hit: false
                });
            }
            
            function updateNotes() {
                const laneHeight = lanes[0].offsetHeight;
                
                // Mettre √† jour chaque note
                for (let i = rhythmState.notes.length - 1; i >= 0; i--) {
                    const note = rhythmState.notes[i];
                    
                    // Mettre √† jour la position
                    note.position += rhythmState.noteSpeed;
                    note.element.style.top = `${note.position}px`;
                    
                    // Si la note est compl√®tement sortie de la lane
                    if (note.position > laneHeight + 20) {
                        // Si la note n'a pas √©t√© frapp√©e
                        if (!note.hit) {
                            rhythmState.combo = 0;
                            updateRhythmDisplay("MISS!");
                        }
                        
                        // Supprimer la note
                        note.element.remove();
                        rhythmState.notes.splice(i, 1);
                    }
                }
            }
            
            //===================================
            // JEU DE QUIZ
            //===================================
            const quizGame = document.getElementById('quiz-game');
            const questionText = document.getElementById('question-text');
            const quizOptions = document.querySelectorAll('.quiz-option');
            const quizFeedback = document.getElementById('quiz-feedback');
            const quizScore = document.getElementById('quiz-score');
            
            // Questions du quiz
            const quizQuestions = [
                {
                    question: "Quelle est la principale caract√©ristique de Camille le nul?",
                    options: ["Il est tr√®s fort", "Il est nul", "Il est rapide", "Il est intelligent"],
                    correctAnswer: 1
                },
                {
                    question: "Quel est le jeu qui a inspir√© le mini-jeu de combat?",
                    options: ["Final Fantasy", "Pokemon", "Undertale", "Dark Souls"],
                    correctAnswer: 2
                },
                {
                    question: "Combien de mini-jeux contient cette collection?",
                    options: ["3", "4", "5", "6"],
                    correctAnswer: 2
                },
                {
                    question: "Dans quel jeu contr√¥le-t-on un c≈ìur rouge?",
                    options: ["Le jeu de plateforme", "Le jeu de quiz", "Le jeu de combat", "Le jeu de rythme"],
                    correctAnswer: 2
                },
                {
                    question: "Que collecte-t-on dans le jeu de plateforme?",
                    options: ["Des √©toiles", "Des pi√®ces", "Des os", "Des c≈ìurs"],
                    correctAnswer: 1
                }
            ];
            
            // √âtat du jeu de quiz
            let quizState = {
                currentQuestion: 0,
                score: 0,
                answered: false
            };
            
            function initQuizGame() {
                // R√©initialiser l'√©tat du jeu
                quizState = {
                    currentQuestion: 0,
                    score: 0,
                    answered: false
                };
                
                // Afficher la premi√®re question
                loadQuestion();
                
                // Ajouter les √©v√©nements aux options
                quizOptions.forEach(option => {
                    option.addEventListener('click', handleQuizOptionClick);
                });
            }
            
            function loadQuestion() {
                const question = quizQuestions[quizState.currentQuestion];
                
                // Afficher la question
                questionText.textContent = question.question;
                
                // Afficher les options
                quizOptions.forEach((option, index) => {
                    option.textContent = question.options[index];
                    option.classList.remove('correct', 'incorrect');
                });
                
                // R√©initialiser le feedback
                quizFeedback.textContent = "";
                
                // Mettre √† jour le score
                quizScore.textContent = `Score: ${quizState.score}/${quizState.currentQuestion}`;
                
                quizState.answered = false;
            }
            
            function handleQuizOptionClick(e) {
                if (quizState.answered) return;
                
                quizState.answered = true;
                const selectedIndex = parseInt(e.target.getAttribute('data-index'));
                const correctIndex = quizQuestions[quizState.currentQuestion].correctAnswer;
                
                // V√©rifier la r√©ponse
                if (selectedIndex === correctIndex) {
                    e.target.classList.add('correct');
                    quizFeedback.textContent = "Correct!";
                    quizFeedback.style.color = "#00ff00";
                    quizState.score++;
                    playSound('perfect');
                } else {
                    e.target.classList.add('incorrect');
                    quizOptions[correctIndex].classList.add('correct');
                    quizFeedback.textContent = "Incorrect!";
                    quizFeedback.style.color = "#ff0000";
                    playSound('miss');
                }
                
                // Passer √† la question suivante apr√®s un d√©lai
                setTimeout(() => {
                    quizState.currentQuestion++;
                    
                    if (quizState.currentQuestion < quizQuestions.length) {
                        loadQuestion();
                    } else {
                        // Fin du quiz
                        questionText.textContent = "Quiz termin√©!";
                        quizFeedback.textContent = `Score final: ${quizState.score}/${quizQuestions.length}`;
                        quizFeedback.style.color = "#ffff00";
                        
                        // Afficher le score final
                        quizScore.textContent = `Score: ${quizState.score}/${quizQuestions.length}`;
                        
                        // Ajouter un bouton pour recommencer
                        const restartButton = document.createElement('button');
                        restartButton.textContent = "Recommencer le quiz";
                        restartButton.className = "restart-button";
                        restartButton.style.margin = "20px auto";
                        restartButton.style.display = "block";
                        
                        restartButton.addEventListener('click', initQuizGame);
                        quizGame.querySelector('.quiz-container').appendChild(restartButton);
                    }
                }, 2000);
            }

            //===================================
            // JEU DE LABYRINTHE
            //===================================
            const mazeContainer = document.getElementById('maze-container');
            
            // √âtat du jeu de labyrinthe
            let mazeState = {
                width: 15,
                height: 10,
                playerX: 1,
                playerY: 1,
                endX: 13,
                endY: 8,
                grid: [],
                keysPressed: {},
                playerElement: null,
                endElement: null,
                lastMoveTime: 0
            };
            
            function initMazeGame() {
                // Nettoyer le labyrinthe existant
                mazeContainer.innerHTML = '';
                
                // R√©initialiser l'√©tat du jeu
                mazeState = {
                    width: 15,
                    height: 10,
                    playerX: 1,
                    playerY: 1,
                    endX: 13,
                    endY: 8,
                    grid: [],
                    keysPressed: {},
                    playerElement: null,
                    endElement: null,
                    lastMoveTime: 0
                };
                
                // G√©n√©rer le labyrinthe
                generateMaze();
                
                // Cr√©er la grille visuelle
                createMazeGrid();
                
                // Ajouter le joueur et la sortie
                addMazeElements();
                
                // Mettre en place les √©v√©nements
                window.addEventListener('keydown', handleMazeKeyDown);
            }
            
            function stopMazeGame() {
                window.removeEventListener('keydown', handleMazeKeyDown);
            }
            
            function generateMaze() {
                // Initialiser la grille avec des murs
                for (let y = 0; y < mazeState.height; y++) {
                    const row = [];
                    for (let x = 0; x < mazeState.width; x++) {
                        // 0 = chemin, 1 = mur
                        row.push(1);
                    }
                    mazeState.grid.push(row);
                }
                
                // Algorithme de g√©n√©ration de labyrinthe (algorithme r√©cursif)
                function carve(x, y) {
                    // Marquer la cellule actuelle comme chemin
                    mazeState.grid[y][x] = 0;
                    
                    // Directions: 0=nord, 1=est, 2=sud, 3=ouest
                    const directions = [0, 1, 2, 3];
                    
                    // M√©langer les directions
                    for (let i = directions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [directions[i], directions[j]] = [directions[j], directions[i]];
                    }
                    
                    // Explorer chaque direction
                    for (let dir of directions) {
                        let nx, ny, nx2, ny2;
                        
                        if (dir === 0) { nx = x; ny = y - 1; nx2 = x; ny2 = y - 2; }      // Nord
                        else if (dir === 1) { nx = x + 1; ny = y; nx2 = x + 2; ny2 = y; } // Est
                        else if (dir === 2) { nx = x; ny = y + 1; nx2 = x; ny2 = y + 2; } // Sud
                        else { nx = x - 1; ny = y; nx2 = x - 2; ny2 = y; }                // Ouest
                        
                        // V√©rifier si la cellule est dans les limites et n'a pas √©t√© visit√©e
                        if (nx2 >= 0 && nx2 < mazeState.width && ny2 >= 0 && ny2 < mazeState.height && mazeState.grid[ny2][nx2] === 1) {
                            // Creuser un chemin √† travers les deux cellules
                            mazeState.grid[ny][nx] = 0;
                            carve(nx2, ny2);
                        }
                    }
                }
                
                // Commencer √† (1,1)
                carve(1, 1);
                
                // Assurer que le d√©but et la fin sont des chemins
                mazeState.grid[mazeState.playerY][mazeState.playerX] = 0;
                mazeState.grid[mazeState.endY][mazeState.endX] = 0;
                
                // Cr√©er un chemin entre le d√©but et la fin
                ensurePath();
            }
            
            function ensurePath() {
                // Algorithme simple pour s'assurer qu'il y a un chemin entre le d√©but et la fin
                // en cr√©ant quelques ouvertures al√©atoires suppl√©mentaires
                for (let i = 0; i < 10; i++) {
                    const x = 1 + Math.floor(Math.random() * (mazeState.width - 2));
                    const y = 1 + Math.floor(Math.random() * (mazeState.height - 2));
                    mazeState.grid[y][x] = 0;
                }
            }
            
            function createMazeGrid() {
                // D√©finir la taille du conteneur
                mazeContainer.style.width = `${mazeState.width * 30}px`;
                mazeContainer.style.height = `${mazeState.height * 30}px`;
                
                // Cr√©er les cellules
                for (let y = 0; y < mazeState.height; y++) {
                    const rowElement = document.createElement('div');
                    rowElement.className = 'maze-row';
                    
                    for (let x = 0; x < mazeState.width; x++) {
                        const cellElement = document.createElement('div');
                        cellElement.className = 'maze-cell';
                        
                        if (mazeState.grid[y][x] === 1) {
                            cellElement.classList.add('maze-wall');
                        }
                        
                        rowElement.appendChild(cellElement);
                    }
                    
                    mazeContainer.appendChild(rowElement);
                }
            }
            
            function addMazeElements() {
                // Ajouter le joueur
                mazeState.playerElement = document.createElement('div');
                mazeState.playerElement.className = 'maze-player';
                mazeState.playerElement.textContent = 'üèÉ';
                
                // Ajouter la sortie
                mazeState.endElement = document.createElement('div');
                mazeState.endElement.className = 'maze-end';
                mazeState.endElement.textContent = 'üö™';
                
                // Ajouter les √©l√©ments √† la grille
                updateMazePlayerPosition();
            }
            
            function updateMazePlayerPosition() {
                // Obtenir les cellules de la grille
                const rows = mazeContainer.querySelectorAll('.maze-row');
                const playerCell = rows[mazeState.playerY].children[mazeState.playerX];
                const endCell = rows[mazeState.endY].children[mazeState.endX];
                
                // Placer le joueur et la sortie
                if (!playerCell.contains(mazeState.playerElement)) {
                    playerCell.appendChild(mazeState.playerElement);
                }
                
                if (!endCell.contains(mazeState.endElement)) {
                    endCell.appendChild(mazeState.endElement);
                }
                
                // V√©rifier si le joueur a atteint la sortie
                if (mazeState.playerX === mazeState.endX && mazeState.playerY === mazeState.endY) {
                    mazeVictory();
                }
            }
            
            function handleMazeKeyDown(e) {
                // Limiter la fr√©quence des mouvements (√©viter les d√©placements trop rapides)
                const now = Date.now();
                if (now - mazeState.lastMoveTime < 150) return;
                mazeState.lastMoveTime = now;
                
                let newX = mazeState.playerX;
                let newY = mazeState.playerY;
                
                // D√©terminer la nouvelle position
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'z') {
                    newY--;
                } else if (e.key === 'ArrowDown' || e.key === 's') {
                    newY++;
                } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'q') {
                    newX--;
                } else if (e.key === 'ArrowRight' || e.key === 'd') {
                    newX++;
                }
                
                // V√©rifier si le mouvement est valide
                if (
                    newX >= 0 && newX < mazeState.width &&
                    newY >= 0 && newY < mazeState.height &&
                    mazeState.grid[newY][newX] === 0
                ) {
                    // Mettre √† jour la position du joueur
                    mazeState.playerX = newX;
                    mazeState.playerY = newY;
                    updateMazePlayerPosition();
                    playSound('select');
                }
            }
            
            function mazeVictory() {
                playSound('victory');
                
                // Afficher un message de victoire
                const victoryMessage = document.createElement('div');
                victoryMessage.textContent = "VICTOIRE!";
                victoryMessage.style.position = "absolute";
                victoryMessage.style.top = "50%";
                victoryMessage.style.left = "50%";
                victoryMessage.style.transform = "translate(-50%, -50%)";
                victoryMessage.style.fontSize = "48px";
                victoryMessage.style.color = "var(--secondary-color)";
                victoryMessage.style.textShadow = "0 0 20px var(--secondary-color)";
                victoryMessage.style.zIndex = "100";
                
                mazeContainer.appendChild(victoryMessage);
                
                // Ajouter un bouton pour recommencer
                const restartButton = document.createElement('button');
                restartButton.textContent = "Recommencer";
                restartButton.className = "restart-button";
                restartButton.style.position = "absolute";
                restartButton.style.top = "60%";
                restartButton.style.left = "50%";
                restartButton.style.transform = "translateX(-50%)";
                restartButton.style.zIndex = "100";
                
                restartButton.addEventListener('click', initMazeGame);
                mazeContainer.appendChild(restartButton);
            }
        });
    </script>
</body>
</html>